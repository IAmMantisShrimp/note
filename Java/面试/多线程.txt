 1.jvm

- 线程A和线程B，堆内存和方法区内存共享。
- 但是栈内存独立，一个线程一个栈。


 并行和并发

并发是在同一个cpu上同时（不是真正的同时，而是看来是同时，因为CPU要在多个程序之间切换）运行多个程序。

   并行是每一个CPU运行一个程序。

  并发是指一个处理器同时处理多个任务。 
  并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。 

 3.多线程的实现方式

1. 继承Thread类

1. 实现Runnable接口

1. 实现Callable接口

   优点：可以获取到线程的执行结果。

   缺点：效率比较低，在获取t线程执行结果的时候，当前线程受阻塞，效率较低。


sleep方法:

让当前正在执行的线程睡眠指定毫秒数

interrupt方法:

终断t线程的睡眠（这种终断睡眠的方式依靠了java的异常处理机制。）

stop:

强行终止线程,缺点:容易损坏数据  线程没有保存的数据容易丢失

yield:

- 暂停当前正在执行的线程对象，并执行其他线程
  yield方法不是阻塞方法。让当前线程让位，让给其它线程使用。
  yield方法的执行会让当前线程从“运行状态”回到“就绪状态”

 sleep和 wait有什么区别

1）sleep是线程类（Thread）的方法；wait是Object类的方法

2）sleep是使线程休眠，不会释放对象锁；wait是使线程等待，释放锁
sleep让出的是cpu,如果此时代码是加锁的，那么即使让出了CPU,其他线程也无法运行，因为没有得到锁；wait是让自己暂时等待，放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。

3）调用sleep进入阻塞状态,调用interrupt方法终止睡眠.

调用wait进入等待状态，调用notify进入就绪状态


 5.线程的调度:

线程调度模型

- 均分式调度模型：所有的线程轮流使用CPU的使用权，平均分配给每一个线程占用CPU的时间。
- 抢占式调度模型：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么就会随机选择一个线程来执行，优先级高的占用CPU时间相对来说会高一点点。

Java中JVM使用的就是抢占式调度模型

- getPriority:获取线程优先级
- setPriority：设置线程优先级

 线程的安全

 1.数据安全问题

- 是否具备多线程的环境
- 是否有共享数据
- 是否有多条语句操作共享数据

例如：我和小明同时取一个账户的钱，我取钱后数据还没返回给服务器，小明又取了，这个时候小明的余额还是原来的。

如何解决？线程排队执行（不能并发），线程同步机制。



 2.变量对线程安全的影响

实例变量：在堆中。

静态变量：在方法区。

局部变量：在栈中。


以上三大变量中：
        局部变量永远都不会存在线程安全问题。
        因为局部变量不共享。（一个线程一个栈。）
        局部变量在栈中。所以局部变量永远都不会共享。


txt
实例变量在堆中，堆只有1个。
    静态变量在方法区中，方法区只有1个。
    堆和方法区都是多线程共享的，所以可能存在线程安全问题。


 局部变量+常量：不会有线程安全问题。
   	成员变量：可能会有线程安全问题。



 3.编程模型 

Java
异步编程模型：
            线程t1和线程t2，各自执行各自的，t1不管t2，t2不管t1，
            谁也不需要等谁，这种编程模型叫做：异步编程模型。
            其实就是：多线程并发（效率较高。）


Java
同步编程模型：
            线程t1和线程t2，在线程t1执行的时候，必须等待t2线程执行
            结束，或者说在t2线程执行的时候，必须等待t1线程执行结束，
            两个线程之间发生了等待关系，这就是同步编程模型。
            效率较低。线程排队执行。




 4.如何解决线程安全问题

Java
是一上来就选择线程同步吗？synchronized
        不是，synchronized会让程序的执行效率降低，用户体验不好。
        系统的用户吞吐量降低。用户体验差。在不得已的情况下再选择
        线程同步机制。


第一种方案：尽量使用局部变量代替“实例变量和静态变量”。 

  第二种方案：如果必须是实例变量，那么可以考虑创建多个对象，这样
   实例变量的内存就不共享了。（一个线程对应1个对象，100个线程对应100个对象，
   对象不共享，就没有数据安全问题了。）

   第三种方案：如果不能使用局部变量，对象也不能创建多个，这个时候
   就只能选择synchronized了。线程同步机制。



 2.synchronized和lock的用法区别

synchronized：在需要同步的对象中加入此控制，synchronized可以加在方法上，也可以加在特定代码块中，括号中表示需要锁的对象。

lock：一般使用ReentrantLock类做为锁。在加锁和解锁处需要通过lock和unlock显示指出。所以一般会在finally块中写unlock以防死锁。

 3.synchronized和lock性能区别

synchronized是托管给JVM执行的，而lock是java写的控制锁的代码。

synchronized原始采用的是CPU悲观锁机制，即线程获得的是独占锁。

而Lock用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。



 4、synchronized和lock用途区别

synchronized原语和ReentrantLock在一般情况下没有什么区别，但是在非常复杂的同步应用中，请考虑使用ReentrantLock，特别是遇到下面2种需求的时候。

- 1.某个线程在等待一个锁的控制权的这段时间需要中断
- 2.需要分开处理一些wait-notify，ReentrantLock里面的Condition应用，能够控制notify哪个线程
- 3.具有公平锁功能，每个到来的线程都将排队等候

 4.synchronized实现原理

Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：

- 普通同步方法，锁是当前实例对象
- 静态同步方法，锁是当前类的class对象
- 同步方法块，锁是括号里面的对象
  当一个线程访问同步代码块时，它首先是需要得到锁，当退出或者抛出异常时必须要释放锁，那么它是如何来实现这个机制的呢？我们先看一段简单的代码：



 5.死锁

形成原因: 当两个线程或者多个线程互相锁定的情况就叫死锁

避免死锁的原则: 顺序上锁，反向解锁，不要回头

 线程池

 1.概念

程池在系统启动时会创建大量空闲线程，程序将一个任务传递给线程池，线程池就会启动一条线程来执行这个任务，执行结束后线程不会销毁（死亡），而是再次返回到线程池中成为空闲状态，等待执行下一个任务。



 2.线程池的工作机制

在线程池的编程模式下，任务是分配给整个线程池的，而不是直接提交给某个线程，线程池拿到任务后，就会在内部寻找是否有空闲的线程，如果有，则将任务交个某个空闲线程。

 3.使用线程池的原因

多线程运行时，系统不断创建和销毁新的线程，成本非常高，会过度的消耗系统资源，从而可能导致系统资源崩溃，使用线程池就是最好的选择。



 4.可重用线程

 Executors.newCacheThreadPoll;  创建一个可缓存的线程池 
 execute(Runnable run)            启动线程池中的线程     


 5.多线程并发的线程安全问题




 以上程序运行并没有达到预期的2000，此处多线程并发，a共享，所以没达到2000; 

会出现多个线程同时操作a++;a还没有加完就被其他线程拿去使用.导致最后没有加到2000