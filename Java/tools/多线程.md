

# 线程

## 1.jvm

- 线程A和线程B，堆内存和方法区内存共享。
- 但是栈内存独立，一个线程一个栈。

![img](https://img-blog.csdnimg.cn/f86be0ff79da458eb3d852b27a8c119b.png)



## 2.java中多线程的生命周期

![img](https://img-blog.csdnimg.cn/36a712dbdff642048611a26849294d1e.png)



![在这里插入图片描述](https://img-blog.csdnimg.cn/20210620110235664.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzQ2ODUzNjcz,size_16,color_FFFFFF,t_70)



## 并行和并发

并发是在同一个cpu上同时（不是真正的同时，而是看来是同时，因为CPU要在多个程序之间切换）运行多个程序。

   并行是每一个CPU运行一个程序。

  并发是指一个处理器同时处理多个任务。 
  并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。 

## 3.多线程的实现方式

1. 继承Thread类

1. 实现Runnable接口

1. 实现Callable接口

   优点：可以获取到线程的执行结果。

   缺点：效率比较低，在获取t线程执行结果的时候，当前线程受阻塞，效率较低。

## 4.线程控制

| 方法名                       | 说明                                             |
| :--------------------------- | :----------------------------------------------- |
| `void yield()`               | 使当前线程让步，重新回到争夺CPU执行权的队列中    |
| `static void sleep(long ms)` | 使当前正在执行的线程停留指定的毫秒数             |
| `void join()`                | 等死（等待当前线程销毁后，再继续执行其它的线程） |
| void interrupt()             | 终止线程睡眠                                     |



sleep()方法:

*让当前正在执行的线程睡眠指定毫秒数*

interrupt()方法:

*终断t线程的睡眠（这种终断睡眠的方式依靠了java的异常处理机制。）*

stop:

*强行终止线程*,*缺点:容易损坏数据  线程没有保存的数据容易丢失*

`yield()`:

- 暂停当前正在执行的线程对象，并执行其他线程
  yield()方法不是阻塞方法。让当前线程让位，让给其它线程使用。
  yield()方法的执行会让当前线程从“运行状态”回到“就绪状态”

## sleep和 wait有什么区别

1）sleep是线程类（Thread）的方法；wait是Object类的方法

2）sleep是使线程休眠，不会释放对象锁；wait是使线程等待，释放锁
sleep让出的是cpu,如果此时代码是加锁的，那么即使让出了CPU,其他线程也无法运行，因为没有得到锁；wait是让自己暂时等待，放弃对象锁，进入等待此对象的等待锁定池，只有针对此对象发出notify方法（或notifyAll）后本线程才进入对象锁定池准备获得对象锁进入运行状态。

3）调用sleep进入阻塞状态,调用interrupt方法终止睡眠.

调用wait进入等待状态，调用notify进入就绪状态







## 5.线程的调度:

线程调度模型

- 均分式调度模型：所有的线程轮流使用CPU的使用权，平均分配给每一个线程占用CPU的时间。
- 抢占式调度模型：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么就会随机选择一个线程来执行，优先级高的占用CPU时间相对来说会高一点点。

Java中JVM使用的就是抢占式调度模型

- `getPriority()`:获取线程优先级
- `setPriority`：设置线程优先级

```Java
/**
 * @author Mr.乐
 * @Description  线程的调度
 */
public class Demo07 {
    public static void main(String[] args) {
        //创建线程
        MyThread t01 = new MyThread("线程01");
        MyThread t02 = new MyThread("线程02");
        MyThread t03 = new MyThread("线程03");
        //获取线程优先级，默认是5
//        System.out.println(t01.getPriority());
//        System.out.println(t02.getPriority());
//        System.out.println(t03.getPriority());
        //设置线程优先级
        t01.setPriority(Thread.MIN_PRIORITY); //低  - 理论上来讲，最后完成
        t02.setPriority(Thread.NORM_PRIORITY); //中
        t03.setPriority(Thread.MAX_PRIORITY); //高  - 理论上来讲，最先完成
        //开启线程
        t01.start();
        t02.start();
        t03.start();
    }
}
```

# 线程的安全

## 1.数据安全问题

- 是否具备多线程的环境
- 是否有共享数据
- 是否有多条语句操作共享数据

例如：我和小明同时取一个账户的钱，我取钱后数据还没返回给服务器，小明又取了，这个时候小明的余额还是原来的。

如何解决？线程排队执行（不能并发），线程同步机制。



## 2.变量对线程安全的影响

实例变量：在堆中。

静态变量：在方法区。

局部变量：在栈中。

```txt
以上三大变量中：
        局部变量永远都不会存在线程安全问题。
        因为局部变量不共享。（一个线程一个栈。）
        局部变量在栈中。所以局部变量永远都不会共享。
```

```txt
实例变量在堆中，堆只有1个。
    静态变量在方法区中，方法区只有1个。
    堆和方法区都是多线程共享的，所以可能存在线程安全问题。
```

 局部变量+常量：不会有线程安全问题。
   	成员变量：可能会有线程安全问题。



## 3.编程模型 

```Java
异步编程模型：
            线程t1和线程t2，各自执行各自的，t1不管t2，t2不管t1，
            谁也不需要等谁，这种编程模型叫做：异步编程模型。
            其实就是：多线程并发（效率较高。）
```

```Java
同步编程模型：
            线程t1和线程t2，在线程t1执行的时候，必须等待t2线程执行
            结束，或者说在t2线程执行的时候，必须等待t1线程执行结束，
            两个线程之间发生了等待关系，这就是同步编程模型。
            效率较低。线程排队执行。
```



## 4.如何解决线程安全问题

```Java
是一上来就选择线程同步吗？synchronized
        不是，synchronized会让程序的执行效率降低，用户体验不好。
        系统的用户吞吐量降低。用户体验差。在不得已的情况下再选择
        线程同步机制。
```

第一种方案：尽量使用局部变量代替“实例变量和静态变量”。 

  第二种方案：如果必须是实例变量，那么可以考虑创建多个对象，这样
   实例变量的内存就不共享了。（一个线程对应1个对象，100个线程对应100个对象，
   对象不共享，就没有数据安全问题了。）

   第三种方案：如果不能使用局部变量，对象也不能创建多个，这个时候
   就只能选择synchronized了。线程同步机制。





# 锁

## 1.synchronized和Lock的区别

![img](https://img-blog.csdnimg.cn/img_convert/6573fa512b38273bcaca2a47ec402831.png)



## 2.**synchronized和lock的用法区别**

synchronized：在需要同步的对象中加入此控制，synchronized可以加在方法上，也可以加在特定代码块中，括号中表示需要锁的对象。

lock：一般使用ReentrantLock类做为锁。在加锁和解锁处需要通过lock()和unlock()显示指出。所以一般会在finally块中写unlock()以防死锁。

## 3.**synchronized和lock性能区别**

synchronized是托管给JVM执行的，而lock是java写的控制锁的代码。

**synchronized原始采用的是CPU悲观锁机制，即线程获得的是独占锁。**

**而Lock用的是乐观锁方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。**



## **4、synchronized和lock用途区别**

synchronized原语和ReentrantLock在一般情况下没有什么区别，但是在非常复杂的同步应用中，请考虑使用ReentrantLock，特别是遇到下面2种需求的时候。

- 1.某个线程在等待一个锁的控制权的这段时间需要中断
- 2.需要分开处理一些wait-notify，ReentrantLock里面的Condition应用，能够控制notify哪个线程
- 3.具有公平锁功能，每个到来的线程都将排队等候

## 4.**synchronized实现原理**

Java中每一个对象都可以作为锁，这是synchronized实现同步的基础：

- 普通同步方法，锁是当前实例对象
- 静态同步方法，锁是当前类的class对象
- 同步方法块，锁是括号里面的对象
  当一个线程访问同步代码块时，它首先是需要得到锁，当退出或者抛出异常时必须要释放锁，那么它是如何来实现这个机制的呢？我们先看一段简单的代码：



## 5.死锁

形成原因: 当两个线程或者多个线程互相锁定的情况就叫死锁

避免死锁的原则: 顺序上锁，反向解锁，不要回头

```java
/**
 * @author Mr.乐
 * @Description 死锁
 */
public class DeadLock {
    public static void main(String[] args) {
        Object o1 = new Object();
        Object o2 = new Object();
 
        // t1和t2两个线程共享o1,o2
        Thread t1 = new MyThread1(o1,o2);
        Thread t2 = new MyThread2(o1,o2);
 
        t1.start();
        t2.start();
    }
}
 
class MyThread1 extends Thread{
    Object o1;
    Object o2;
    public MyThread1(Object o1,Object o2){
        this.o1 = o1;
        this.o2 = o2;
    }
    public void run(){
        synchronized (o1){
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (o2){
 
            }
        }
    }
}
 
class MyThread2 extends Thread {
    Object o1;
    Object o2;
    public MyThread2(Object o1,Object o2){
        this.o1 = o1;
        this.o2 = o2;
    }
    public void run(){
        synchronized (o2){
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            synchronized (o1){
 
            }
        }
    }
}
```





# 线程池

## 1.概念

程池在系统启动时会创建大量空闲线程，程序将一个任务传递给线程池，线程池就会启动一条线程来执行这个任务，执行结束后线程不会销毁（死亡），而是再次返回到线程池中成为空闲状态，等待执行下一个任务。



## 2.线程池的工作机制

在线程池的编程模式下，任务是分配给整个线程池的，而不是直接提交给某个线程，线程池拿到任务后，就会在内部寻找是否有空闲的线程，如果有，则将任务交个某个空闲线程。

## 3.使用线程池的原因

多线程运行时，系统不断创建和销毁新的线程，成本非常高，会过度的消耗系统资源，从而可能导致系统资源崩溃，使用线程池就是最好的选择。



## 4.可重用线程

| 方法名                            | 说明                   |
| :-------------------------------- | :--------------------- |
| `Executors.newCacheThreadPoll();` | 创建一个可缓存的线程池 |
| `execute(Runnable run)`           | 启动线程池中的线程     |

```Java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
 
/**
 * @author Mr.乐
 * @Description  可重用线程池
 */
public class ExecutorsTest {
    public static void main(String[] args) {
        //创建线程池
        ExecutorService threadPoll = Executors.newCachedThreadPool();
 
        for (int i = 0; i < 10; i++) {
            //如果不睡眠，那么第一个执行完的线程无法及时成为空闲线程，那么线程池就会让一个新的线程执行
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            //每次循环都会开启一个线程
            threadPoll.execute(new Runnable() {
                @Override
                public void run() {
                    System.out.println(Thread.currentThread().getName() + "正在被执行！~");
                }
            });
        }
        threadPoll.shutdown();//关闭线程池
        //线程池是无限大，当执行当前任务时，上一个任务已经完成，会重复执行上一个任务的线程，而不是每次使用新的线程
    }
}
```



## 5.多线程并发的线程安全问题

```Java
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
 
/**
 * @author Mr.乐
 * @Description  并发安全
 */
public class MyTest {
    //定义静态变量
    static int a=0;
    static int count=2000;
    public static void main(String[] args) {
       //创建线程池
        ExecutorService service = Executors.newCachedThreadPool();
        for(int i=0;i<count;i++){
            service.execute(new Runnable() {
                @Override
                public void run() {
                    a++;
                }
            });
        }
        关闭线程池
        service.shutdown();
        System.out.println(a);
        //1987
    }
}
```

 以上程序运行并没有达到预期的2000，此处多线程并发，a共享，所以没达到2000; 

会出现多个线程同时操作a++;a还没有加完就被其他线程拿去使用.导致最后没有加到2000

 方案1,加锁:

```java
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
 
/**
 * @author Mr.乐
 * @Description  并发安全
 */
public class MyTest {
    static int a=0;
    static int count=2000;
    public static void main(String[] args) throws InterruptedException {
        ExecutorService service = Executors.newCachedThreadPool();
        //闭锁 在一些条件下可放开  参数:加多少把锁
        CountDownLatch countDownLatch=new CountDownLatch(count);
        for(int i=0;i<count;i++){
            service.execute(new Runnable() {
                @Override
                public void run() {
                    a++;
                    //解一把锁
                    countDownLatch.countDown();
                }
            });
        }
        service.shutdown();
        //会进入阻塞状态  什么时候把锁全解了   阻塞状态才会解除
        countDownLatch.await();
        System.out.println(a);
        //1987
    }
}
```

此处所用的加锁方法也没有实现预期效果。



## 6.CPU多级缓存

![img](https://img-blog.csdnimg.cn/35d273bb3bb3449fa3d0302d3dffbccb.png)

程序进程中的数据，都在内存中存着。 而CPU缓存，是为了解决内存没有CPU快的问题。当一个数据需要CPU修改，而内存无法及时给CPU返回数据，就会拖慢CPU的运行速度。所以有了CPU缓存。

​    当CPU需要在内存中读数据时，在时间局部性上（不久的将来）还得读此数据。，将此数据放在CPU缓存中。

![img](https://img-blog.csdnimg.cn/0be4a90ea2d244c9b44e3c48c02d5b9b.png)

当CPU读取数据时，会让CPU缓存同步内存中的数据。然后CPU缓存中的数据再交给CPU去修改。当CPU修改完后，会把修改的数据传给CPU缓存（此时CPU不需要等待），再由CPU缓存传给内存 。 

当CPU 01将数据修改完后，CPU缓存01还没有将数据传给内存，CPU缓存02读到了a，此时a的值为0。

 以下为线程安全的两种方式: 加锁和信号

```java
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
 
/**
 * @author Mr.乐
 * @Description  并发安全 synchronized
 */
public class MyTest {
    static int a=0;
    static int count=2000;
    public static void main(String[] args) throws InterruptedException {
        ExecutorService service = Executors.newCachedThreadPool();
        //闭锁 在一些条件下可放开  参数:加多少把锁
        CountDownLatch countDownLatch=new CountDownLatch(count);
        for(int i=0;i<count;i++){
            service.execute(new Runnable() {
                @Override
                public void run() {
                    synchronized (MyTest.class) {
                        a++;
                        //解一把锁
                        countDownLatch.countDown();
                    }
                }
            });
        }
        service.shutdown();
        //会进入阻塞状态  什么时候把锁全解了   阻塞状态才会解除
        countDownLatch.await();
        System.out.println(a);
        //2000
    }
}
-------------------------------------------------------------------
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Semaphore;
 
/**
 * @author Mr.乐
 * @Description  并发安全 synchronized
 */
public class MyTest {
    static int a=0;
    static int count=2000;
    public static void main(String[] args) throws InterruptedException {
        ExecutorService service = Executors.newCachedThreadPool();
        //闭锁 在一些条件下可放开  参数:加多少把锁
        CountDownLatch countDownLatch=new CountDownLatch(count);
        //信号量
        Semaphore semaphore=new Semaphore(1);
        for(int i=0;i<count;i++){
            service.execute(new Runnable() {
                @Override
                public void run() {
                    try {  //拿走一个信号
                        semaphore.acquire();
                        a++;
                        //解一把锁
                        countDownLatch.countDown();
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }finally {
                        //释放信号
                        semaphore.release();
                    }
                }
            });
        }
        service.shutdown();
        //会进入阻塞状态  什么时候把锁全解了   阻塞状态才会解除
        countDownLatch.await();
        System.out.println(a);
        //2000
    }
}
 
```















